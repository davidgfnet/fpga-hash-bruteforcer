
# Each stage contains:
#   A:B:C:D [128] state bits
#   32 bits of message (M[i])
# It gets instanced with a static "k" constant, rotation amount "s[i]"
#  and M[g], where g is calculated using i (staticalliy)
#
# The instance has a message input channel, that esentially contains
#  2 bytes and 2 offsets, indicating the next two bytes that should
#  be changed

ks = [
	"32'hd76aa478", "32'he8c7b756", "32'h242070db", "32'hc1bdceee",
	"32'hf57c0faf", "32'h4787c62a", "32'ha8304613", "32'hfd469501",
	"32'h698098d8", "32'h8b44f7af", "32'hffff5bb1", "32'h895cd7be",
	"32'h6b901122", "32'hfd987193", "32'ha679438e", "32'h49b40821",
	"32'hf61e2562", "32'hc040b340", "32'h265e5a51", "32'he9b6c7aa",
	"32'hd62f105d", "32'h02441453", "32'hd8a1e681", "32'he7d3fbc8",
	"32'h21e1cde6", "32'hc33707d6", "32'hf4d50d87", "32'h455a14ed",
	"32'ha9e3e905", "32'hfcefa3f8", "32'h676f02d9", "32'h8d2a4c8a",
	"32'hfffa3942", "32'h8771f681", "32'h6d9d6122", "32'hfde5380c",
	"32'ha4beea44", "32'h4bdecfa9", "32'hf6bb4b60", "32'hbebfbc70",
	"32'h289b7ec6", "32'heaa127fa", "32'hd4ef3085", "32'h04881d05",
	"32'hd9d4d039", "32'he6db99e5", "32'h1fa27cf8", "32'hc4ac5665",
	"32'hf4292244", "32'h432aff97", "32'hab9423a7", "32'hfc93a039",
	"32'h655b59c3", "32'h8f0ccc92", "32'hffeff47d", "32'h85845dd1",
	"32'h6fa87e4f", "32'hfe2ce6e0", "32'ha3014314", "32'h4e0811a1",
	"32'hf7537e82", "32'hbd3af235", "32'h2ad7d2bb", "32'heb86d391",
]

sa = [
	7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
	5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
	4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
	6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,
]

def g(i):
	if   i < 16: return i
	elif i < 32: return (5*i+1) % 16
	elif i < 48: return (3*i+5) % 16
	else:        return (7*i+0) % 16

print """// THIS FILE IS AUTOGENERATED BY gen.py SCRIPT
`timescale 1ns / 1ps

module md5_pipeline(
	input         clk,

	input  [ 5:0] offset_in,  // 6 bit offset to update
	input  [ 7:0] msbyte_in,  // 8 bit byte to overwrite

	// Only output the 64 LSB for the hash, since we assume
	// the number of collisions (false positives) is going to be very
	// low (2^-64 * hashrate) even at large hashrates (~1GH/sec)
	// We save one stage doing so (we could output A for 96b output at same cost)
	output reg [31:0] c_out,      // 32 bit C
	output reg [31:0] d_out       // 32 bit D
);

"""

#	/*integer i;
#	initial begin
#	for (i = 0; i <= 65; i = i+1) begin
#	$dumpvars(0, offset[i]);
#	$dumpvars(0, byte[i]);
#	$dumpvars(0, pipe_b[i]);
#	$dumpvars(0, pipe_c[i]);
#	$dumpvars(0, pipe_d[i]);
#	$dumpvars(0, pipe_p[i]);
#	end
#	end*/

# Pipe wires
for name, width in {"offset": 6, "byte": 8, "pipe_b": 32, "pipe_c": 32, "pipe_d": 32, "pipe_p": 32 }.items():
	print "\twire [%2d:0] %6s [ 0:65];" % (width-1, name)

print """
	reg [ 5:0] offset_in_buf; // Buffer to allow some routing delay
	reg [ 7:0] msbyte_in_buf;
	always @(posedge clk) begin
		offset_in_buf <= offset_in;
		msbyte_in_buf <= msbyte_in;
	end

	// Input data is placed in p1, b1, c1 and d1
	//  p1 it's essentially a1 with some tranforms, therefore the input mapping
	//  that needs to be done is
	// [B] in p0->b1, [C] in b0->c1, [D] in c0->d1, [A] in d0->p1
	// a0,c0,d0 are not used, some signals are optimized away for the first stages (constant)

	assign pipe_d[0] = 32'h67452301;  // A
	assign pipe_b[1] = 32'hefcdab89;  // B
	assign pipe_c[1] = 32'h98badcfe;  // C
	assign pipe_d[1] = 32'h10325476;  // D

	assign offset[0] = offset_in_buf;
	assign   byte[0] = msbyte_in_buf;
"""

for j in range(64):
	i = j
	print """
	md5_pre_stage #( .message_number(%d), .konstant(%s) ) md5pre%d (
		.clk(clk),
		.d_in(pipe_d[%d]),
		.offset_in (offset[%d]), .msbyte_in (byte[%d]),
		.offset_out(offset[%d]), .msbyte_out(byte[%d]),
		.p_out(pipe_p[%d])
	);""" % (g(i), ks[i], i, i,i,i, i+1,i+1,i+1)

	i = j+1
	print """
	md5_post_stage #( .stage_number(%d), .rot_amount(%d) ) md5post%d (
		.clk(clk),
		.b_in (pipe_b[%d]), .c_in (pipe_c[%d]), .d_in (pipe_d[%d]), .p_in (pipe_p[%d]),
		.b_out(pipe_b[%d]), .c_out(pipe_c[%d]), .d_out(pipe_d[%d])
	);""" % (i-1, sa[i-1], i-1, i,i,i,i, i+1,i+1,i+1)

# Output is a65:b65:c65:d65, a64 must be flopped from d64
print """
	// Output calculation (endian swap them)
	// Could optimize away additions
	always @(posedge clk) begin
		c_out <= pipe_c[65] + 32'h98badcfe;
		d_out <= pipe_d[65] + 32'h10325476;
	end
"""

print "endmodule"



